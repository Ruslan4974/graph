#lang racket
(define Graph ‘((“A”  “B”) (“A”  “D”) (“B”  “D”) (“C”  “B”) (“C”  “D”) (“D”  “E”) (“E”  “F”) (“F”  “G”) (“G”  “H”) (“H”  “E”)))
;;рассматриваем путь от s до d в графе G
(define (reach s d G)
;;если вершина s уже равна d – значит мы уже достигли пункт назначения, т.е. ;;добрались из s в d
	(cond [(equal? S d) #t] ;;проверяем, s=d или нет, если это так, то true
		[(null? G)       #f] ;;в противном случае нельзя перейти из s в d, false

		[ else
(let*                        ([Edge (first G)]
			[a (first Edge)]
			[b (second Edge)]
;;рассмотрим проигрышную ситуацию, когда попытаемся найти путь от s до d, ;;не используя первое ребро графа
			[lose-it (reach s d (rest G))]
;;собираемся использовать первое ребро, поэтому вызываем reach от s до a
			[use-it (and (reach s a (rest G))
;;вызываем reach от b до d

				  (reach b d (rest G)))])

				(or lose-it use-it))]))
