#lang racket
(define Graph ‘((“A”  “B”) (“A”  “D”) (“B”  “D”) (“C”  “B”) (“C”  “D”) (“D”  “E”) (“E”  “F”) (“F”  “G”) (“G”  “H”) (“H”  “E”)))
;;рассматриваем путь от s до d в графе G
(define (reach s d G)
;;если вершина s уже равна d – значит мы уже достигли пункт назначения, т.е. ;;добрались из s в d
;;пропишем сразу крайние случаи
	(cond [(equal? S d) #t] ;;проверяем, s=d или нет, если это так, то true
		[(null? G)       #f] ;;в противном случае нельзя перейти из s в d, false
;;далее начинаем рассматривать по порядку с первого ребра графа G
		[ else
(let*                        ([Edge (first G)]
;;пусть назовем и укажем первым ребром A, а B - вторым ребром 
			[a (first Edge)]
			[b (second Edge)]
;;рассмотрим проигрышную ситуацию, когда попытаемся найти путь от s до d, ;;не используя первое ребро графа
			[lose-it (reach s d (rest G))]
;;собираемся использовать первое ребро, поэтому вызываем reach от s до a
			[use-it (and (reach s a (rest G))
;;вызываем reach от b до d
;;так как нам известно такое ребро из задачи
				  (reach b d (rest G)))])
;;оба выше описанных случая должны быть правдой, поэтому выполняются ;;вместе, значит нужно иметь пути от s к a и от b к d
::используемое или потерянное будут (каждый из них) или истинным, ;;или ;;ложным. Получится добраться до вершины, если получится добраться из ;;двух выше описанных ситуаций без первого ребра либо используя его
				(or lose-it use-it))]))
